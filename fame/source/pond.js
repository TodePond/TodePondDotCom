let SAVE =
  "camera:x=1735,y=-682,scale=0.0758;entities:;id=6,source=Grass2Flip.png,text=undefined,x=2914,y=-105,z=0,scale=0.6634,rotation=0.0000;id=1,source=Grass2.png,text=undefined,x=-505,y=1669,z=0,scale=0.7098,rotation=0.0000;id=0,source=Colours/FroggyYellow.png,text=Sebastian Andreasson,x=914,y=1011,z=0,scale=1.0000,rotation=0.0000;id=4,source=Grass2.png,text=undefined,x=-877,y=871,z=0,scale=0.5652,rotation=0.0000;id=2,source=Colours/FroggyOrange.png,text=Flora Caulton,x=431,y=604,z=0,scale=1.0000,rotation=0.0000;id=5,source=Colours/FroggyCyanFlip.png,text=@walpolea,x=88,y=219,z=0,scale=1.0000,rotation=0.0000;id=7,source=Colours/FroggyRed.png,text=Max Bittker,x=1287,y=602,z=0,scale=1.0000,rotation=0.0000;id=8,source=Grass2Flip.png,text=undefined,x=1549,y=-376,z=0,scale=0.6437,rotation=3.3262;id=9,source=Grass2.png,text=undefined,x=1545,y=-351,z=0,scale=0.4732,rotation=0.0000;id=10,source=Grass2Flip.png,text=undefined,x=-490,y=1707,z=0,scale=0.4709,rotation=0.0000;id=11,source=Colours/FroggyCyanFlip.png,text=Gill W,x=809,y=239,z=0,scale=1.0000,rotation=0.0000;id=12,source=Colours/FroggyOrangeFlip.png,text=Latchy,x=-137,y=743,z=0,scale=1.0000,rotation=0.0000;id=13,source=Grass.png,text=undefined,x=-25,y=-382,z=0,scale=0.8531,rotation=0.0000;id=14,source=Grass2.png,text=undefined,x=-151,y=-419,z=0,scale=0.7277,rotation=0.0000;id=15,source=GrassFlip.png,text=undefined,x=1401,y=1572,z=0,scale=0.9950,rotation=0.0000;id=16,source=Grass2Flip.png,text=undefined,x=1534,y=1552,z=0,scale=0.7845,rotation=0.0000;id=3,source=Colours/FroggyRedFlip.png,text=Florent Loock,x=271,y=1055,z=0,scale=1.0000,rotation=0.0000;id=18,source=Flower.png,text=undefined,x=1506,y=1551,z=0,scale=0.4160,rotation=0.0000;id=17,source=Colours/FroggyYellow.png,text=George McGhee,x=421,y=-162,z=0,scale=1.0000,rotation=0.0000;id=19,source=Flower.png,text=undefined,x=-948,y=716,z=0,scale=0.4732,rotation=87.1535;id=21,source=Colours/FroggyGreen.png,text=The Saddest Biccy - A Pitiful Digestive,x=1546,y=32,z=0,scale=1.0000,rotation=0.0000;id=22,source=Colours/FroggyGreenFlip.png,text=@poorsquid,x=-456,y=432,z=0,scale=1.0000,rotation=0.0000;id=20,source=Colours/FroggyBlue.png,text=Magnogen,x=1614,y=961,z=0,scale=1.0000,rotation=0.0000;id=23,source=Flower.png,text=undefined,x=1504,y=-473,z=0,scale=0.3405,rotation=38.0634;id=24,source=Flower.png,text=undefined,x=1584,y=-537,z=0,scale=0.4541,rotation=53.6506;id=25,source=Colours/FroggyRedFlip.png,text=Dimitar Irinkov,x=1066,y=-281,z=0,scale=1.0000,rotation=0.0000;id=26,source=Colours/FroggyRed.png,text=Chrysophlax,x=1878,y=473,z=0,scale=1.0000,rotation=0.0000;id=27,source=Grass2.png,text=undefined,x=2163,y=221,z=0,scale=0.5006,rotation=0.0000;id=28,source=Grass2Flip.png,text=undefined,x=2171,y=218,z=0,scale=0.4907,rotation=0.0000;id=29,source=Colours/FroggyRedFlip.png,text=Collo,x=-270,y=-104,z=0,scale=1.0000,rotation=0.0000;id=30,source=Colours/FroggyRed.png,text=SeungBum Kim,x=1905,y=-299,z=0,scale=1.0000,rotation=0.0000;id=31,source=Colours/FroggyRed.png,text=Andy Bayer,x=2202,y=873,z=0,scale=1.0000,rotation=0.0000;id=32,source=Colours/FroggyGreenFlip.png,text=Erik Jonasson,x=529,y=-627,z=0,scale=1.0000,rotation=0.0000;id=33,source=Colours/FroggyLilac.png,text=livcomp,x=1172,y=-770,z=0,scale=1.0000,rotation=0.0000;id=34,source=Colours/FroggyRed.png,text=Hayden Jackson,x=2552,y=233,z=0,scale=1.0000,rotation=0.0000;id=35,source=Grass2.png,text=undefined,x=-684,y=109,z=0,scale=0.5296,rotation=0.0000;id=36,source=Colours/FroggyRedFlip.png,text=Brian Zindler,x=-587,y=949,z=0,scale=1.0000,rotation=0.0000;id=37,source=Colours/FroggyYellowFlip.png,text=antovsky,x=-617,y=-423,z=0,scale=1.0000,rotation=0.0000;id=39,source=Colours/FroggyWhite.png,text=Patrick Kennedy,x=2527,y=-230,z=0,scale=1.0000,rotation=0.0000;id=40,source=Grass.png,text=undefined,x=2608,y=759,z=0,scale=0.9405,rotation=0.0000;id=41,source=Flower.png,text=undefined,x=2506,y=746,z=0,scale=0.4518,rotation=53.6506;id=42,source=Grass2.png,text=undefined,x=852,y=697,z=0,scale=0.5270,rotation=0.0000;id=43,source=Colours/FroggyLilacFlip.png,text=Ax2u,x=-961,y=272,z=0,scale=1.0000,rotation=0.0000;id=44,source=Colours/FroggyOrangeFlip.png,text=Willhart,x=135,y=-945,z=0,scale=1.0000,rotation=0.0000;id=45,source=Colours/FroggyCyan.png,text=Maxence,x=1658,y=-1056,z=0,scale=1.0000,rotation=0.0000;id=46,source=Grass2.png,text=undefined,x=818,y=-784,z=0,scale=0.5006,rotation=0.0000;id=47,source=Grass2Flip.png,text=undefined,x=826,y=-787,z=0,scale=0.4907,rotation=0.0000;id=48,source=Colours/FroggyRedFlip.png,text=Filip Optołowicz,x=1216,y=-1375,z=0,scale=1.0000,rotation=0.0000;id=49,source=Colours/FroggyRed.png,text=Matt Giallourakis,x=628,y=-1249,z=0,scale=1.0000,rotation=0.0000;id=50,source=Colours/FroggyGreenFlip.png,text=culi,x=-468,y=-853,z=0,scale=1.0000,rotation=0.0000;id=51,source=Colours/FroggyCyanFlip.png,text=stolksdorf,x=775,y=1443,z=0,scale=1.0000,rotation=0.0000;id=52,source=Colours/FroggyBlue.png,text=Anton Little,x=1997,y=1365,z=0,scale=1.0000,rotation=0.0000;id=53,source=Grass2.png,text=undefined,x=269,y=-1242,z=0,scale=0.5101,rotation=0.0000;id=54,source=Flower.png,text=undefined,x=228,y=-1378,z=0,scale=0.4057,rotation=151.8003;id=55,source=Colours/FroggyYellowFlip.png,text=Raphaël de Courville,x=-273,y=-1313,z=0,scale=1.0000,rotation=0.0000;id=56,source=Colours/FroggyRed.png,text=Craig Fouts,x=2657,y=-1026,z=0,scale=1.0000,rotation=0.0000;id=57,source=Colours/FroggySilver.png,text=Monad,x=2087,y=-1298,z=0,scale=1.0000,rotation=0.0000;id=58,source=Colours/FroggyGreen.png,text=Sage Fiorentino-Lange,x=2158,y=-814,z=0,scale=1.0000,rotation=0.0000;id=59,source=Colours/FroggyLilac.png,text=SimplyLinn,x=1652,y=-1599,z=0,scale=1.0000,rotation=0.0000;id=60,source=Colours/FroggyGreenFlip.png,text=Fuzzyzilla,x=841,y=-1637,z=0,scale=1.0000,rotation=0.0000;id=61,source=Colours/FroggyLilacFlip.png,text=disconcision,x=67,y=-1702,z=0,scale=1.0000,rotation=0.0000;id=62,source=Grass2Flip.png,text=undefined,x=-891,y=-695,z=0,scale=0.6437,rotation=3.3262;id=63,source=Grass2.png,text=undefined,x=-895,y=-670,z=0,scale=0.4057,rotation=0.0000;id=64,source=Flower.png,text=undefined,x=-849,y=-833,z=0,scale=0.3942,rotation=38.0634;id=65,source=Grass2.png,text=undefined,x=2435,y=-1282,z=0,scale=0.5101,rotation=0.0000;id=66,source=Flower.png,text=undefined,x=2429,y=-1426,z=0,scale=0.4057,rotation=234.3996;id=67,source=Colours/FroggyRedFlip.png,text=Scott Cardoza,x=-1139,y=-163,z=0,scale=1.0000,rotation=0.0000;id=68,source=Colours/FroggyOrange.png,text=Desktoy Sam,x=2197,y=-1759,z=0,scale=1.0000,rotation=0.0000;id=69,source=Colours/FroggyRedFlip.png,text=alex,x=-1168,y=-594,z=0,scale=1.0000,rotation=0.0000;id=70,source=Colours/FroggyRedFlip.png,text=Mollie Rose,x=-899,y=-1246,z=0,scale=1.0000,rotation=0.0000;id=71,source=Colours/FroggyRedFlip.png,text=Jethro,x=-593,y=-1659,z=0,scale=1.0000,rotation=0.0000;id=72,source=Colours/FroggyYellowFlip.png,text=John Fresco,x=494,y=-1983,z=0,scale=1.0000,rotation=0.0000;id=74,source=Grass2.png,text=undefined,x=908,y=-1964,z=0,scale=0.5006,rotation=0.0000;id=75,source=Grass2Flip.png,text=undefined,x=917,y=-1952,z=0,scale=0.4207,rotation=0.0000;id=76,source=Colours/FroggyRed.png,text=Kyle,x=1789,y=-2035,z=0,scale=1.0000,rotation=0.0000;id=77,source=Colours/FroggyOrangeFlip.png,text=Steve Ruiz,x=-177,y=-2071,z=0,scale=1.0000,rotation=0.0000;id=78,source=Colours/FroggyRedFlip.png,text=MG,x=-218,y=1314,z=0,scale=1.0000,rotation=0.0000;id=79,source=Colours/FroggyRed.png,text=migujorg,x=2668,y=1140,z=0,scale=1.0000,rotation=0.0000;id=80,source=Colours/FroggyPinkFlip.png,text=Vanawy,x=217,y=1557,z=0,scale=1.0000,rotation=0.0000;id=81,source=Grass2.png,text=undefined,x=2164,y=1908,z=0,scale=0.5006,rotation=0.0000;id=82,source=Grass2Flip.png,text=undefined,x=2172,y=1910,z=0,scale=0.4907,rotation=0.0000;id=83,source=Grass2Flip.png,text=undefined,x=2190,y=-2081,z=0,scale=0.6634,rotation=0.0000;id=84,source=Grass2Flip.png,text=undefined,x=-652,y=-1963,z=0,scale=0.6437,rotation=3.3262;id=85,source=Grass2.png,text=undefined,x=-656,y=-1938,z=0,scale=0.4732,rotation=0.0000;id=86,source=Flower.png,text=undefined,x=-697,y=-2060,z=0,scale=0.3405,rotation=38.0634;id=87,source=Flower.png,text=undefined,x=-617,y=-2124,z=0,scale=0.4541,rotation=53.6506;id=88,source=Colours/FroggyPink.png,text=gay spider,x=3106,y=888,z=0,scale=1.0000,rotation=0.0000;id=89,source=Colours/FroggyLilac.png,text=Julia V,x=3156,y=444,z=0,scale=1.0000,rotation=0.0000;id=91,source=Colours/FroggyRedFlip.png,text=Jimmy Miller,x=1048,y=1866,z=0,scale=1.0000,rotation=0.0000;id=92,source=Colours/FroggyRed.png,text=Richard Forney,x=1761,y=1815,z=0,scale=1.0000,rotation=0.0000;id=93,source=Colours/FroggyLilacFlip.png,text=Tanz,x=-187,y=1897,z=0,scale=1.0000,rotation=0.0000;id=94,source=Colours/FroggyRedFlip.png,text=Booyah,x=-807,y=1757,z=0,scale=1.0000,rotation=0.0000;id=96,source=Colours/FroggyCyanFlip.png,text=OmniToad,x=478,y=1990,z=0,scale=1.0000,rotation=0.0000;id=97,source=Colours/FroggyRedFlip.png,text=Don't Be TREE,x=-1258,y=875,z=0,scale=1.0000,rotation=0.0000;id=98,source=Colours/FroggyLilacFlip.png,text=Patrick Taynor,x=-1018,y=1319,z=0,scale=1.0000,rotation=0.0000;id=99,source=Colours/FroggyRedFlip.png,text=Márton Klecska,x=-1465,y=434,z=0,scale=1.0000,rotation=0.0000;id=100,source=Colours/FroggyRed.png,text=Andrew Walker,x=3194,y=1384,z=0,scale=1.0000,rotation=0.0000;id=101,source=Colours/FroggyRedFlip.png,text=Max Goodhart,x=-1445,y=1640,z=0,scale=1.0000,rotation=0.0000;id=102,source=Colours/FroggyRed.png,text=Titouan,x=2726,y=-1930,z=0,scale=1.0000,rotation=0.0000;id=103,source=Colours/FroggyRed.png,text=Max,x=2862,y=-1465,z=0,scale=1.0000,rotation=0.0000;id=104,source=Grass2Flip.png,text=undefined,x=-1579,y=1320,z=0,scale=0.5688,rotation=0.0000;id=105,source=Grass2.png,text=undefined,x=-1595,y=1324,z=0,scale=0.5296,rotation=0.0000;id=106,source=Grass2.png,text=undefined,x=3141,y=-1024,z=0,scale=0.6389,rotation=0.0000;id=107,source=Colours/FroggyOrange.png,text=Jack Wild,x=2938,y=-632,z=0,scale=1.0000,rotation=0.0000;id=108,source=Grass.png,text=undefined,x=3250,y=-905,z=0,scale=0.9405,rotation=0.0000;id=109,source=Flower.png,text=undefined,x=3284,y=-982,z=0,scale=0.4720,rotation=134.5973;id=110,source=Colours/FroggyYellow.png,text=Lewis,x=3749,y=268,z=0,scale=1.0000,rotation=0.0000;id=111,source=Colours/FroggyYellowFlip.png,text=Guillaume Bergerot,x=-1699,y=-28,z=0,scale=1.0000,rotation=0.0000;id=112,source=Colours/FroggyCyan.png,text=Chris,x=3652,y=709,z=0,scale=1.0000,rotation=0.0000;id=113,source=Colours/FroggyRedFlip.png,text=Pellerin Léonard,x=-1483,y=-1052,z=0,scale=1.0000,rotation=0.0000;id=114,source=Colours/FroggyGreen.png,text=Bruno Dantas,x=3562,y=-500,z=0,scale=1.0000,rotation=0.0000;id=115,source=Colours/FroggyBlue.png,text=Oliver,x=3257,y=-1752,z=0,scale=1.0000,rotation=0.0000;id=117,source=Colours/FroggyRed.png,text=Anna Chamberlain,x=3618,y=-1425,z=0,scale=1.0000,rotation=0.0000;id=118,source=Colours/FroggyRed.png,text=Sawyer McLane,x=3831,y=-931,z=0,scale=1.0000,rotation=0.0000;id=73,source=Colours/FroggyRed.png,text=Surma,x=3235,y=-12,z=0,scale=1.0000,rotation=0.0000;id=90,source=Colours/FroggyRedFlip.png,text=dan-lee,x=1227,y=-1929,z=0,scale=1.0000,rotation=0.0000;id=119,source=Colours/FroggyGreen.png,text=Peter Brodersen,x=3732,y=1149,z=0,scale=1.0000,rotation=0.0000;id=120,source=Colours/FroggyRed.png,text=João Guilherme Madeira Araújo,x=4055,y=-163,z=0,scale=1.0000,rotation=0.0000;id=121,source=Colours/FroggyRed.png,text=Wilsown,x=4226,y=-586,z=0,scale=1.0000,rotation=0.0000;id=122,source=Colours/FroggyRedFlip.png,text=Angelo Ashmore,x=-1755,y=-472,z=0,scale=1.0000,rotation=0.0000;id=123,source=Colours/FroggyRed.png,text=Alec Resnick,x=4297,y=411,z=0,scale=1.0000,rotation=0.0000;id=124,source=Colours/FroggyRedFlip.png,text=Eliko,x=-1872,y=853,z=0,scale=1.0000,rotation=0.0000;id=125,source=Colours/FroggyCyanFlip.png,text=Meow,x=-2089,y=408,z=0,scale=1.0000,rotation=0.0000;id=126,source=Colours/FroggyRedFlip.png,text=Proxtx,x=-2020,y=1371,z=0,scale=1.0000,rotation=0.0000;id=127,source=Colours/FroggyLilacFlip.png,text=Allain Lalonde,x=-2048,y=-897,z=0,scale=1.0000,rotation=0.0000;id=128,source=Colours/FroggyRedFlip.png,text=domlazic,x=-1862,y=-1413,z=0,scale=1.0000,rotation=0.0000;id=129,source=Colours/FroggyBlueFlip.png,text=n-gons,x=-2267,y=-161,z=0,scale=1.0000,rotation=0.0000;id=130,source=Colours/FroggyRedFlip.png,text=Kybe,x=-2497,y=982,z=0,scale=1.0000,rotation=0.0000;id=131,source=Colours/FroggyRedFlip.png,text=Robb Beal,x=-2620,y=211,z=0,scale=1.0000,rotation=0.0000;id=132,source=Colours/FroggyRedFlip.png,text=Russel Simmons,x=-2485,y=-617,z=0,scale=1.0000,rotation=0.0000;id=133,source=Colours/FroggyPink2Flip.png,text=Joshix,x=-2449,y=-1215,z=0,scale=1.0000,rotation=0.0000;id=139,source=Colours/FroggyRed.png,text=Ell,x=3911,y=-1799,z=0,scale=1.0000,rotation=0.0000;id=140,source=Colours/FroggyLilacFlip.png,text=parameterized,x=-1244,y=-1564,z=0,scale=1.0000,rotation=0.0000;id=141,source=Colours/FroggyRedFlip.png,text=SNDTST,x=-1087,y=-2026,z=0,scale=1.0000,rotation=0.0000;id=142,source=Colours/FroggyYellowFlip.png,text=SomehowSane,x=-2909,y=-246,z=0,scale=1.0000,rotation=0.0000;id=143,source=Colours/FroggyRedFlip.png,text=Das Gürteltier,x=-1706,y=-1939,z=0,scale=1.0000,rotation=0.0000;id=144,source=Colours/FroggyRedFlip.png,text=Murch,x=-3276,y=169,z=0,scale=1.0000,rotation=0.0000;id=145,source=Colours/FroggyWhiteFlip.png,text=transistor fet,x=-2931,y=-854,z=0,scale=1.0000,rotation=0.0000;id=146,source=Colours/FroggyLilac.png,text=Books,x=4263,y=-1242,z=0,scale=1.0000,rotation=0.0000;id=147,source=Colours/FroggyGreenFlip.png,text=forresto,x=-2324,y=-1662,z=0,scale=1.0000,rotation=0.0000;id=148,source=Colours/FroggySilverFlip.png,text=k,x=-2939,y=588,z=0,scale=1.0000,rotation=0.0000;id=149,source=Colours/FroggyPink.png,text=Nona,x=4201,y=910,z=0,scale=1.0000,rotation=0.0000;id=150,source=Grass2Flip.png,text=undefined,x=-2942,y=1070,z=0,scale=0.5688,rotation=0.0000;id=151,source=Grass2.png,text=undefined,x=-2951,y=1098,z=0,scale=0.3854,rotation=0.0000;id=152,source=Grass2Flip.png,text=undefined,x=-2941,y=-1317,z=0,scale=0.6437,rotation=3.3262;id=153,source=Grass2.png,text=undefined,x=-2945,y=-1292,z=0,scale=0.4732,rotation=0.0000;id=154,source=Flower.png,text=undefined,x=-2986,y=-1414,z=0,scale=0.3405,rotation=38.0634;id=155,source=Flower.png,text=undefined,x=-2906,y=-1478,z=0,scale=0.4541,rotation=53.6506;id=156,source=Grass.png,text=undefined,x=-3560,y=-324,z=0,scale=0.8958,rotation=0.0000;id=157,source=Grass2.png,text=undefined,x=-3383,y=-333,z=0,scale=0.5617,rotation=15.0754;id=158,source=Grass2.png,text=undefined,x=4211,y=1369,z=0,scale=0.5006,rotation=0.0000;id=159,source=Grass2Flip.png,text=undefined,x=4219,y=1366,z=0,scale=0.4907,rotation=0.0000;id=160,source=Flower.png,text=undefined,x=-3695,y=-296,z=0,scale=0.4744,rotation=53.6506;id=161,source=GrassFlip.png,text=undefined,x=4701,y=-233,z=0,scale=0.9950,rotation=0.0000;id=162,source=Grass2Flip.png,text=undefined,x=4834,y=-253,z=0,scale=0.7845,rotation=0.0000;id=163,source=Grass2.png,text=undefined,x=4500,y=-1487,z=0,scale=0.5006,rotation=0.0000;id=164,source=Grass2Flip.png,text=undefined,x=4509,y=-1475,z=0,scale=0.4417,rotation=0.0000;id=137,source=Colours/FroggyCyan.png,text=Laure B,x=4733,y=-861,z=0,scale=1.0000,rotation=0.0000;id=171,source=Colours/FroggyLilac.png,text=nach,x=2629,y=1650,z=0,scale=1.0000,rotation=0.0000;id=172,source=Colours/FroggyLilacFlip.png,text=Benjamin Wrensch,x=-3308,y=-1164,z=0,scale=1.0000,rotation=0.0000;routes:";
const urlParams = new URLSearchParams(window.location.search);

const EDIT_MODE = urlParams.has("edit");
const RENDER_MODE = urlParams.has("render");

const stage = Stage.make();
const { canvas, context } = stage;

const camera = { x: 0, y: 0, scale: 1, scaleMod: 1 };
const entities = new Map();
const freeEntityIds = new Set();
const layers = new Map();
const routes = new Map();
const freeRouteIds = new Set();

const selectedEntities = new Set();
const selectionBoxStart = [undefined, undefined];

const imageCache = new Map();

// Make an entity AND THEN place it on the map
const createEntity = (...args) => {
  const entity = makeEntity(...args);
  registerEntity(entity);
  if (entity.text === undefined) {
    entity.text = "";
  }
  return entity;
};

// Get an entity id that is free to use (note: remember to remove it from the freeEntityIds list if you use it)
const getNewId = () => {
  findFreeEntityIds();
  if (freeEntityIds.size > 0) {
    return freeEntityIds.values().next().value;
  } else return entities.size;
};

// Place an entity on the map
const registerEntity = (entity) => {
  const id = getNewId();
  loadEntity(entity, id);
  return id;
};

// Place an entity on the map in a specific id
const loadEntity = (entity, id) => {
  entity.id = id;
  entities.set(id, entity);
  freeEntityIds.delete(id);
  const { z } = entity;
  if (layers.get(z) === undefined) {
    layers.set(z, new Map());
  }
  const layer = layers.get(z);
  layer.set(id, entity);
};

const moveLayer = (entity, dz) => {
  const z = entity.z;
  const layer = layers.get(z);
  const id = entity.id;
  layer.delete(id);
  const nz = z + dz;
  if (layers.get(nz) === undefined) {
    layers.set(nz, new Map());
  }
  const newLayer = layers.get(nz);
  newLayer.set(id, entity);
  entity.z = nz;
};

// Remove an entity from the map
const unregisterEntity = (id) => {
  const entity = entities.get(id);
  freeEntityIds.add(id);
  entities.delete(id);

  const { z } = entity;
  const layer = layers.get(z);
  layer.delete(id);
  if (layer.size === 0) layer.delete(z);
};

// Remove all entities
const unregisterAllEntities = () => {
  freeEntityIds.clear();
  entities.clear();
  layers.clear();
};

// Make an entity object
const makeEntity = (
  source,
  {
    x = 0,
    y = 0,
    z = 0,
    scale = 1,
    rotation = 0,
    text,
    ignoreSave = false,
  } = {}
) => {
  const image = getImage(source);
  const entity = {
    id: undefined,
    source,
    image,
    x,
    y,
    z,
    scale,
    rotation,
    text,
    ignoreSave,
  };
  return entity;
};

// Get an image element (make one if needed)
const getImage = (source) => {
  if (source === undefined) return new Image();
  const cachedImage = imageCache.get(source);
  if (cachedImage !== undefined) return cachedImage;
  const image = new Image();
  image.src = `images/${source}`;
  imageCache.set(source, image);
  return image;
};

const titleStyle = HTML`<style>
	#title {
		position: absolute;
		top: 0px;
		color: rgb(224, 224, 224);
		font-family: Rosario;
		width: 100vw;
		text-align: center;
		font-size: 80px;
		user-select: none;
		/*text-decoration: underline;*/
		margin: 0;
	}
</style>`;
const title = HTML`<div id="title"></div>`;

const nomargin = HTML`<style>* {margin: 0px;}</style>`;
on.load(() => {
  document.head.appendChild(nomargin);
  document.body.appendChild(canvas);
  document.body.style["margin"] = "0px";
  canvas.style["background-color"] = "rgb(23, 29, 40)";
  //canvas.style["background-color"] = "#06070a"
  trigger("resize");
  load(SAVE);

  document.head.appendChild(titleStyle);
  document.body.appendChild(title);
});

on.resize(() => {
  canvas.width = innerWidth * devicePixelRatio;
  canvas.height = innerHeight * devicePixelRatio;
  canvas.style.width = innerWidth;
  canvas.style.height = innerHeight;
  if (innerWidth < 1920) {
    camera.scaleMod = (innerWidth / 1080) * devicePixelRatio;
    //camera.scaleMod = devicePixelRatio
  } else {
    camera.scaleMod = devicePixelRatio;
  }
});

let clipboard = [];
on.keydown((e) => {
  if (e.key === "Delete") {
    for (const entity of selectedEntities) {
      unregisterEntity(entity.id);
    }
    return;
  }
  if (e.key === "=") {
    for (const entity of selectedEntities.values()) {
      moveLayer(entity, 1);
    }
    return;
  }
  if (e.key === "-") {
    for (const entity of selectedEntities.values()) {
      moveLayer(entity, -1);
    }
    return;
  }
  if (e.ctrlKey) {
    if (e.key === "p" || e.key === "d") {
      e.preventDefault();
      for (const entity of selectedEntities.values()) {
        print("Entity:", entity);
      }
      return;
    }
    if (e.key === "c") {
      clipboard = [];
      for (const entity of selectedEntities.values()) {
        clipboard.push({ ...entity });
      }
      return;
    }
    if (e.key === "v") {
      selectedEntities.clear();
      for (const entity of clipboard) {
        entity.d;
        const paste = createEntity(entity.source, { ...entity });
        paste.d;
        selectedEntities.add(paste);
      }
      return;
    }
  }
});

const findFreeEntityIds = () => {
  const founds = [false].repeat(entities.size);
  for (const entity of entities.values()) {
    founds[entity.id] = true;
  }
  const frees = [];
  for (const i in founds) {
    if (!founds[i]) frees.push(i.as(Number));
  }
  freeEntityIds.clear();
  for (const free of frees) {
    freeEntityIds.add(free);
  }
};

const onMouseWheel = (e) => {
  e.preventDefault();
  let { deltaY } = e;
  if (!deltaY) {
    return;
  }
  deltaY = deltaY / Math.abs(deltaY);

  if (e.altKey) {
    for (const entity of selectedEntities) {
      const zoom = -deltaY * (entity.scale - entity.scale * (1 - 0.05));
      entity.scale += zoom;
      if (entity.scale < 0) entity.scale = 0;
    }
    updateHovers();
    return;
  }
  const zoom = -deltaY * (camera.scale - camera.scale * (1 - 0.05));
  camera.scale += zoom;
  if (camera.scale < 0) camera.scale = 0;
  updateHovers();
};

on.wheel((e) => onMouseWheel(e), { passive: false });

on.touchmove(
  (e) => {
    e.preventDefault();
    if (touchCount === 1) {
      const [x, y] = [e.touches[0].clientX, e.touches[0].clientY];
      camera.x =
        touchCameraStart[0] +
        (touchOrigin[0] - x * devicePixelRatio) /
          (camera.scale * camera.scaleMod);
      camera.y =
        touchCameraStart[1] +
        (touchOrigin[1] - y * devicePixelRatio) /
          (camera.scale * camera.scaleMod);
    } else if (touchCount === 2) {
      const [left, right] = e.touches;
      const [lx, ly] = [left.clientX, left.clientY];
      const [rx, ry] = [right.clientX, right.clientY];
      const pinch = Math.hypot(rx - lx, ry - ly);
      camera.scale = pinchCameraStart * (pinch / pinchStart);
    }
  },
  { passive: false }
);

let touchCount = 0;
const touchOrigin = [0, 0];
const touchCameraStart = [0, 0];

let pinchStart = 0;
let pinchCameraStart = 0;

on.touchstart((e) => {
  if (touchCount === 0) {
    touchCount = 1;
    touchOrigin[0] = e.touches[0].clientX * devicePixelRatio;
    touchOrigin[1] = e.touches[0].clientY * devicePixelRatio;
    touchCameraStart[0] = camera.x;
    touchCameraStart[1] = camera.y;
  } else if (touchCount === 1) {
    touchCount = 2;
    const [left, right] = e.touches;
    const [lx, ly] = [left.clientX, left.clientY];
    const [rx, ry] = [right.clientX, right.clientY];
    pinchStart = Math.hypot(rx - lx, ry - ly);
    pinchCameraStart = camera.scale;
  }
});

on.touchend((e) => {
  touchCount = e.touches.length;
  if (touchCount === 1) {
    touchOrigin[0] = e.touches[0].clientX * devicePixelRatio;
    touchOrigin[1] = e.touches[0].clientY * devicePixelRatio;
    touchCameraStart[0] = camera.x;
    touchCameraStart[1] = camera.y;
  }
});

on.touchcancel((e) => {
  touchCount = e.touches.length;
  if (touchCount === 1) {
    touchOrigin[0] = e.touches[0].clientX * devicePixelRatio;
    touchOrigin[1] = e.touches[0].clientY * devicePixelRatio;
    touchCameraStart[0] = camera.x;
    touchCameraStart[1] = camera.y;
  }
});

on.mousemove(
  (e) => {
    e.preventDefault();
    updateHovers();
    if (Mouse.Middle || (!EDIT_MODE && (Mouse.Left || Mouse.Right))) {
      const { movementX, movementY } = e;
      camera.x -= movementX / (camera.scale * camera.scaleMod);
      camera.y -= movementY / (camera.scale * camera.scaleMod);
    } else if (Mouse.Right) {
      const { movementX, movementY } = e;

      if (e.altKey) {
        const [mx, my] = Mouse.position;
        for (const entity of selectedEntities) {
          const space = getEntitySpace(entity);
          const [cx, cy] = space.center;
          const [dx, dy] = [cx - mx, cy - my];
          entity.rotation += (movementY * -dx) / 2000;
          entity.rotation += (movementX * dy) / 2000;
        }
        updateHovers();
        return;
      }

      for (const entity of selectedEntities.values()) {
        entity.x += movementX / camera.scale / camera.scaleMod;
        entity.y += movementY / camera.scale / camera.scaleMod;
      }
    }
  },
  { passive: false }
);

on.mousedown(
  (e) => {
    e.preventDefault();
    if (!EDIT_MODE) return;
    if (e.button === 0) {
      const [mx, my] = Mouse.position;
      selectionBoxStart[0] = mx;
      selectionBoxStart[1] = my;
    }
  },
  { passive: false }
);

on.mouseup((e) => {
  if (!EDIT_MODE) return;
  if (e.button === 0) {
    const [mx, my] = Mouse.position;
    const [sx, sy] = selectionBoxStart;
    if (sx !== undefined || sy !== undefined) {
      let hits = selectedEntities;
      if (sx === mx && sy === my) {
        const hit = getHit(mx, my);
        if (hit !== undefined) {
          if ((e.shiftKey || e.ctrlKey) && selectedEntities.has(hit)) {
            selectedEntities.delete(hit);
          } else hits = new Set([hit]);
        } else hits = new Set();
      } else {
        hits = getSelects([sx, sy], [mx, my]);
      }

      if (!e.shiftKey && !e.ctrlKey) {
        selectedEntities.clear();
      }

      for (const hit of hits.values()) {
        selectedEntities.add(hit);
      }

      selectionBoxStart[0] = undefined;
      selectionBoxStart[1] = undefined;
    }
  }
});

on.contextmenu((e) => {
  if (RENDER_MODE) return;
  e.preventDefault();
});

const getHits = (x, y) => {
  const hits = new Set();
  for (const entity of entities.values()) {
    const space = getEntitySpace(entity);
    const isCollision = isSpaceCollision([x, y], space);
    if (isCollision) hits.add(entity);
  }
  return hits;
};

const getHit = (x, y) => {
  const hits = getHits(x, y);
  const hit = findTopHit(hits);
  return hit;
};

const findTopHit = (hits) => {
  const dummy = { z: -Infinity };
  const hit = [...hits.values()].reduce((a, b) => (a.z > b.z ? a : b), dummy);
  if (dummy === hit) return undefined;
  return hit;
};

const updateHovers = () => {
  if (!EDIT_MODE) return;
  const [mx, my] = Mouse.position;
  const [sx, sy] = selectionBoxStart;
  if (sx === undefined || sy === undefined) {
    const hits = getHits(mx, my);
    const hit = findTopHit(hits);
    for (const entity of entities.values()) {
      if (hit === entity) {
        entity.highlight = true;
        entity.hover = true;
      } else if (hits.has(entity)) {
        entity.hover = true;
        entity.highlight = false;
      } else {
        entity.hover = false;
        entity.highlight = false;
      }
    }
    return;
  } else {
    const hits = getSelects([sx, sy], [mx, my]);
    for (const entity of entities.values()) {
      if (hits.has(entity)) {
        entity.hover = true;
        entity.highlight = true;
      } else {
        entity.hover = false;
        entity.highlight = false;
      }
    }
  }
};

const getSelects = ([sx, sy], [mx, my]) => {
  const hits = new Set();
  const selection = {
    rotation: 0,
    position: [sx, sy],
    center: [sx + (mx - sx) / 2, sy + (my - sy) / 2],
    dimensions: [mx - sx, my - sy],
  };
  for (const entity of entities.values()) {
    const space = getEntitySpace(entity);
    // TODO: replace with actual rectangle collision detection (instead of faking it with point collision detection)
    if (isSpaceCollision([mx, my], space)) {
      hits.add(entity);
      continue;
    }
    if (isSpaceCollision([sx, sy], space)) {
      hits.add(entity);
      continue;
    }
    if (isSpaceCollision(selection.center, space)) {
      hits.add(entity);
      continue;
    }
    if (isSpaceCollision(space.center, selection)) {
      hits.add(entity);
      continue;
    }
    for (const corner of space.corners) {
      const rcorner = rotate(corner, space.center, space.rotation);
      if (isSpaceCollision(rcorner, selection)) {
        hits.add(entity);
        break;
      }
    }
  }
  return hits;
};

// https://en.wikipedia.org/wiki/Polar_coordinate_system#Converting_between_polar_and_Cartesian_coordinates
const rotate = ([x, y], [ox, oy], radians) => {
  const [dx, dy] = [x - ox, y - oy];
  const d = Math.sqrt(dx ** 2 + dy ** 2);
  const angle = Math.atan2(dy, dx);
  const [rx, ry] = [
    d * Math.cos(radians + angle),
    d * Math.sin(radians + angle),
  ];
  return [ox + rx, oy + ry];
};

const isSpaceCollision = (
  [x, y],
  { rotation, position, center, dimensions }
) => {
  if (rotation !== 0) {
    const [rx, ry] = rotate([x, y], center, -rotation);
    return isSpaceCollision([rx, ry], {
      rotation: 0,
      position,
      center,
      dimensions,
    });
  }

  const [px, py] = position;
  const [width, height] = dimensions;

  const left = Math.min(px, px + width);
  const right = Math.max(px, px + width);
  const top = Math.min(py, py + height);
  const bottom = Math.max(py, py + height);

  if (x < left) return false;
  if (x > right) return false;
  if (y < top) return false;
  if (y > bottom) return false;
  return true;
};

const toRadians = (degrees) => (degrees * Math.PI) / 180;
const toDegrees = (radians) => (radians * 180) / Math.PI;

const makeSpace = ({
  scale = 1,
  x = 0,
  y = 0,
  width = 100,
  height = 100,
  rotation = 0,
}) => {
  const w = scale * width * camera.scale * camera.scaleMod;
  const h = scale * height * camera.scale * camera.scaleMod;
  const dimensions = [w, h];

  const px =
    canvas.width / 2 +
    (x - camera.x - (width * scale) / 2) * camera.scale * camera.scaleMod;
  const py =
    canvas.height / 2 +
    (y - camera.y - (height * scale) / 2) * camera.scale * camera.scaleMod;
  const position = [px, py];

  const cx = px + w / 2;
  const cy = py + h / 2;
  const center = [cx, cy];

  const corners = [
    [px, py],
    [px + w, py],
    [px + w, py + h],
    [px, py + h],
  ];

  return {
    dimensions,
    position,
    center,
    corners,
    rotation: toRadians(rotation),
  };
};

const getEntitySpace = (entity) => {
  const image = entity.image;
  const [width, height] = [image.width, image.height];
  const { scale, x, y, rotation } = entity;
  return makeSpace({ scale, x, y, width, height, rotation });
};

const getRouteId = () => {
  if (freeRouteIds.size > 0) {
    return freeRouteIds.values().next().value;
  }
  return routes.size;
};

const deleteRoute = (id) => {
  freeRouteIds.add(id);
  routes.delete(id);
};

const deleteAllRoutes = () => {
  freeRouteIds.clear();
  routes.clear();
};

const createRoute = (
  start,
  end,
  {
    id = getRouteId(),
    length = 5000,
    type = "snake",
    flip = false,
    slope = 0.5,
  } = {}
) => {
  const route = { start, end, length, type, flip, slope, id };
  freeRouteIds.delete(id);
  routes.set(id, route);
  return route;
};

const getCurve = (
  [ax, ay],
  [bx, by],
  { length = 5000, type = "snake", flip = false, slope = 0.5 } = {}
) => {
  const [dx, dy] = [bx - ax, by - ay];
  let [ix, iy] = [dx / length, dy / length];
  if (flip) [ix, iy] = [iy, ix];
  const points = [];
  const previous = [ax, ay];
  for (const i of (0).to(length - 1)) {
    const [px, py] = previous;
    let [jx, jy] = [ix, iy];
    if (type === "snake") {
      const easing = Math.min(i, length - 1 - i);
      const racing = length / 2 - 1 - easing;

      const ease = (easing * slope + racing) / (1 + slope);
      const race = (racing * slope + easing) / (1 + slope);

      jx = (ix * 2 * race) / (length / 2 - 1);
      jy = (iy * 2 * ease) / (length / 2 - 1);
    } else if (type === "single") {
      const easing = length - 1 - i;
      const racing = i;

      const ease = (easing * slope + racing) / (1 + slope);
      const race = (racing * slope + easing) / (1 + slope);

      jx = (ix * 2 * ease) / (length - 1);
      jy = (iy * 2 * race) / (length - 1);
    }
    if (flip) [jx, jy] = [jy, jx];
    const [x, y] = [px + jx, py + jy];
    points.push([x, y]);
    previous[0] = x;
    previous[1] = y;
  }
  return points;
};

let flightDelay = 0;
const animateRoute = (route, plane = 0) => {
  const r = routes.get(route);
  const p = entities.get(plane);
  p.flying = true;
  r.flightProgress = 0;
  r.flying = true;
  flightDelay = 200;
};

const MAX_SPEED = 2;
let prevRoute = undefined;
let prevPlaneRot = undefined;
stage.draw = () => {
  context.clearRect(0, 0, canvas.width, canvas.height);

  context.textAlign = "center";

  // Non-Plane Images
  const zs = [...layers.keys()].sort((a, b) => a - b);
  for (const z of zs) {
    const layer = layers.get(z);
    for (const entity of layer.values()) {
      if (entity.source === "Plane.png") continue;

      const { image } = entity;
      let { dimensions, rotation, center } = getEntitySpace(entity);

      const [width, height] = dimensions;
      const [cx, cy] = center;
      const [ox, oy] = [-width / 2, -height / 2];

      context.translate(cx, cy);
      context.rotate(rotation);
      context.drawImage(image, ox, oy, width, height);
      if (entity.text !== "undefined") {
        //haha woops

        let s = 70;
        let fo = 0.95;
        context.font = `${70}px Rosario`;
        const w = context.measureText(entity.text, 0, 0).width;
        if (entity.ignoreSave) {
          // dodgy way of detecting flappy hero
          s = 60;
          fo = 0.8;
        } else if (w > 1000) {
          s = 55;
          fo = 0.92;
        }

        context.font = `${
          s * entity.scale * camera.scale * camera.scaleMod
        }px Rosario`;
        context.strokeStyle = "rgb(23, 29, 40)";
        context.lineWidth = 10 * entity.scale * camera.scale * camera.scaleMod;
        context.lineJoin = "round";
        context.strokeText(entity.text, ox + width / 2, oy + width * fo);
        context.fillStyle = "rgb(224, 224, 224)";
        context.fillText(entity.text, ox + width / 2, oy + width * fo);
      }
      context.rotate(-rotation);
      context.translate(-cx, -cy);
    }
  }

  // Routes
  context.lineWidth = 26 * camera.scale * camera.scaleMod;
  context.setLineDash([
    100 * camera.scale * camera.scaleMod,
    50 * camera.scale * camera.scaleMod,
  ]);
  context.strokeStyle = "rgba(224, 224, 224)";

  let currentFrame = undefined;

  for (const route of routes.values()) {
    const { start, end, slope, length, type, flip } = route;
    const s = entities.get(start);
    const e = entities.get(end);
    if (s === undefined || e === undefined) {
      deleteRoute(route.id);
      continue;
    }
    const [sx, sy] = getEntitySpace(s).center;
    const [ex, ey] = getEntitySpace(e).center;
    const curve = getCurve([sx, sy], [ex, ey], { slope, length, type, flip });

    context.beginPath();
    context.moveTo(sx, sy);
    let i = -1;
    let previous = [sx, sy];
    for (const [x, y] of curve) {
      i++;
      if (route.flying && i > route.flightProgress) {
        currentFrame = [previous, [x, y]];
        break;
      }
      context.lineTo(x, y, ex, ey);
      previous = [x, y];
    }
    if (route.flying && flightDelay <= 0) {
      prevRoute = route;
      const easing =
        Math.min(
          route.flightProgress + route.length / 8,
          route.length - 1 - route.flightProgress
        ) * MAX_SPEED;

      route.flightProgress += MAX_SPEED;
      let penalty = MAX_SPEED - easing / (route.length / 3);
      penalty;
      if (penalty > MAX_SPEED - MAX_SPEED * 0.06)
        penalty = MAX_SPEED - MAX_SPEED * 0.06;
      route.flightProgress -= penalty;

      if (route.flightProgress >= length) {
        route.flying = false;
      }
    }
    flightDelay--;
    context.stroke();
  }

  // Plane Images
  for (const z of zs) {
    const layer = layers.get(z);
    for (const entity of layer.values()) {
      if (entity.source !== "Plane.png") continue;

      const { image } = entity;
      let { dimensions, rotation, center } = getEntitySpace(entity);

      if (entity.flying) {
        if (currentFrame === undefined) {
          const end = entities.get(prevRoute.end);
          entity.x = end.x;
          entity.y = end.y;
          entity.rotation = toDegrees(prevPlaneRot);
          entity.flying = false;
          let newSpace = getEntitySpace(entity);
          dimensions = newSpace.dimensions;
          rotation = newSpace.rotation;
          center = newSpace.center;
        } else {
          const [prev, next] = currentFrame;
          const [px, py] = prev;
          const [nx, ny] = next;
          const [dx, dy] = [nx - px, ny - py];
          rotation = Math.atan2(dy, dx);
          center = next;
          prevPlaneRot = rotation;
        }
      }

      const [width, height] = dimensions;
      const [cx, cy] = center;
      const [ox, oy] = [-width / 2, -height / 2];

      context.translate(cx, cy);
      context.rotate(rotation);
      context.drawImage(image, ox, oy, width, height);
      context.rotate(-rotation);
      context.translate(-cx, -cy);
    }
  }

  // Hovers
  context.lineWidth = 5 * camera.scale * camera.scaleMod;
  context.setLineDash([]);
  for (const entity of entities.values()) {
    let { dimensions, rotation, center } = getEntitySpace(entity);

    if (entity.flying) {
      const [prev, next] = currentFrame;
      const [px, py] = prev;
      const [nx, ny] = next;
      const [dx, dy] = [nx - px, ny - py];
      rotation = Math.atan2(dy, dx);
      center = next;
    }

    const [width, height] = dimensions;
    const [cx, cy] = center;
    const [ox, oy] = [-width / 2, -height / 2];

    context.translate(cx, cy);
    context.rotate(rotation);

    if (entity.highlight) {
      context.fillStyle = "rgba(0, 128, 255, 25%)";
      context.fillRect(ox, oy, width, height);
    }

    if (selectedEntities.has(entity)) {
      context.strokeStyle = "rgba(0, 255, 128)";
      context.strokeRect(ox, oy, width, height);
    } else if (entity.hover) {
      context.strokeStyle = "rgba(0, 128, 255)";
      context.strokeRect(ox, oy, width, height);
    }

    context.rotate(-rotation);
    context.translate(-cx, -cy);
  }

  if (Mouse.Left) {
    const [sx, sy] = selectionBoxStart;
    if (sx !== undefined && sy !== undefined) {
      const [mx, my] = Mouse.position;
      context.strokeStyle = "rgba(0, 128, 255)";
      context.strokeRect(sx, sy, mx - sx, my - sy);
      context.fillStyle = "rgba(0, 128, 255, 25%)";
      context.fillRect(sx, sy, mx - sx, my - sy);
    }
  }
};

// Save the map state to a string
const save = () => {
  const lines = [];
  lines.push(
    `camera:x=${Math.round(camera.x)},y=${Math.round(
      camera.y
    )},scale=${camera.scale.toFixed(4)}`
  );
  lines.push(`entities:`);
  for (const entity of entities.values()) {
    if (entity.ignoreSave) continue;
    lines.push(
      `id=${entity.id},source=${entity.source},text=${
        entity.text
      },x=${Math.round(entity.x)},y=${Math.round(entity.y)},z=${Math.round(
        entity.z
      )},scale=${entity.scale.toFixed(4)},rotation=${entity.rotation.toFixed(
        4
      )}`
    );
  }
  lines.push(`routes:`);
  for (const route of routes.values()) {
    lines.push(
      `id=${route.id},start=${route.start},end=${route.end},length=${route.length},type=${route.type},flip=${route.flip},slope=${route.slope}`
    );
  }
  return lines.join(`;`);
};

const Load = MotherTode(`
	:: Camera ";" Entities ";" Routes EOF
	Camera (
		:: "camera:x=" Number ",y=" Number ",scale=" Number
		>> ([c, x, _1, y, _2, scale]) => {
			camera.x = x.output
			camera.y = y.output
			camera.scale = scale.output
		}
	)
	Entities :: "entities:" { Entity }
	Entity (
		:: ";id=" Number ",source=" String ",text=" String ",x=" Number ",y=" Number ",z=" Number ",scale=" Number ",rotation=" Number
		?? ([_1, id, _2, source, _a, text, _3, x, _4, y, _5, z, _6, scale, _7, rotation]) => {
			const entity = makeEntity(source.output, {x: x.output, y: y.output, z: z.output, scale: scale.output, rotation: rotation.output, text: text.output})
			loadEntity(entity, id.output)
			return true
		}
	)
	Routes :: "routes:" { Route }
	Route (
		:: ";id=" Number ",start=" Number ",end=" Number ",length=" Number ",type=" String ",flip=" Boolean ",slope=" Number
		?? ([_1, id, _2, start, _3, end, _4, length, _5, type, _6, flip, _7, slope]) => {
			const route = createRoute(start.output, end.output, {id: id.output, length: length.output, type: type.output, flip: flip.output, slope: slope.output})
			return true
		}
	)
	String :: /[^,]/+
	Number :: "-"? /[0-9.]/+ >> (n) => n.output.as(Number)
	Boolean :: True | False
	True :: "true" >> true
	False :: "false" >> false
`);

// Load a map state
const load = (save) => {
  MotherTode.Term.resetCache();
  unregisterAllEntities();
  const result = Load(save);
  if (!result.success) {
    console.log(result);
    result.smartLog();
    result.log();
  }
  return result;
};
